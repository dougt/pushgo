/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package simplepush

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"testing"
	"time"

	_ "github.com/rafrombrc/gomock/gomock"
)

// certBytes is a PEM-encoded TLS certificate with the SANs "127.0.0.1",
// "[::1]", and "example.com," expiring at the end of the century.
// Generated by:
//
// go run $GOROOT/src/crypto/tls/generate_cert.go  --rsa-bits 512
// --host 127.0.0.1,::1,example.com --ca --duration=1000000h
// --start-date "Jan 1 00:00:00 1970"
var certBytes = []byte(`-----BEGIN CERTIFICATE-----
MIIBijCCATagAwIBAgIQd2rCdX3G0SZfJwuVK1Lm9TALBgkqhkiG9w0BAQswEjEQ
MA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2MDAw
MFowEjEQMA4GA1UEChMHQWNtZSBDbzBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDu
WHXmPI0/ojwB+2CxtU9y2PuZrd7MjPuGVQa2AABy24bzkdXsJtB7wyHAYI3ZXjxD
PTmhZCumHlw5G6oFG8VTAgMBAAGjaDBmMA4GA1UdDwEB/wQEAwIApDATBgNVHSUE
DDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MC4GA1UdEQQnMCWCC2V4YW1w
bGUuY29thwR/AAABhxAAAAAAAAAAAAAAAAAAAAABMAsGCSqGSIb3DQEBCwNBANqJ
1ZIr96OyB8ZqWuIef85MjwNNOFHWbyh8/KZXfKN/MyEreV3pb/1JYh+Mek1MIXrJ
vSZjMPekPD7UeKK4s7E=
-----END CERTIFICATE-----
`)

// keyBytes is the private key for certBytes.
var keyBytes = []byte(`-----BEGIN RSA PRIVATE KEY-----
MIIBOwIBAAJBAO5YdeY8jT+iPAH7YLG1T3LY+5mt3syM+4ZVBrYAAHLbhvOR1ewm
0HvDIcBgjdlePEM9OaFkK6YeXDkbqgUbxVMCAwEAAQJAHRKZPv4/1HU7kJpTDxoo
mL+y4On+dUD1JUuVx/l0FI5KQul6ieOJ0WFi1tCM1O8NSWXmNsWwJfzMr/XdHWoL
EQIhAPbfdJbQv64W000vdJr1YtPDWnalkmHoqRRmhScAaJ0/AiEA9yhMNhi129kU
19N8tWvEgxCpERnMDuweaOk+SIBnTu0CIQCJ7f8t5CO0GHymO0Vi7obw2czJTWij
22HcTAtI5ymL8QIgdYQyoHIlXjAcifZj0Hs6R7tPN/NVJC8+0lE8rQpolI0CIQDY
XNhdoyyytnuHfc5BLViRCCVR2iU5ev3zfRsrdlhXVA==
-----END RSA PRIVATE KEY-----
`)

// newTLSConfig returns a new TLS configuration object with the test
// certificate and private key.
func newTLSConfig() (conf *tls.Config, err error) {
	cert, err := tls.X509KeyPair(certBytes, keyBytes)
	if err != nil {
		return nil, err
	}
	x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
	if err != nil {
		return nil, err
	}
	certPool := x509.NewCertPool()
	certPool.AddCert(x509Cert)
	conf = &tls.Config{
		ServerName:   "example.com",
		RootCAs:      certPool,
		Certificates: []tls.Certificate{cert},
	}
	return conf, nil
}

// closeAfter is like time.After, but returns a Boolean channel that is
// closed after duration d. This allows multiple select statements to
// receive from the same timer channel.
func closeAfter(d time.Duration) <-chan bool {
	tick := make(chan bool)
	time.AfterFunc(d, func() { close(tick) })
	return tick
}

// drainReader drains and closes the ReadCloser rc.
func drainReader(rc io.ReadCloser) {
	io.Copy(ioutil.Discard, rc)
	rc.Close()
}

// mockHostname implements Hostnamer.
type mockHostname string

func (h mockHostname) Hostname() string { return string(h) }

// mockKeepAliver wraps a net.Conn with fake keep-alive methods.
type mockKeepAliver struct {
	net.Conn
	keepAlive       bool
	keepAlivePeriod time.Duration
}

func (c *mockKeepAliver) SetKeepAlive(v bool) error {
	c.keepAlive = v
	return nil
}

func (c *mockKeepAliver) SetKeepAlivePeriod(d time.Duration) error {
	c.keepAlivePeriod = d
	return nil
}

func (c *mockKeepAliver) Reset() {
	c.keepAlive = false
	c.keepAlivePeriod = 0
}

// connOnly hides the optional keepAliver methods of a net.Conn.
type connOnly struct {
	net.Conn
}

// stubConn is a fake net.Conn for testing.
type stubConn int

func (stubConn) Read([]byte) (int, error)         { return 0, io.EOF }
func (stubConn) Write([]byte) (int, error)        { return 0, io.EOF }
func (stubConn) Close() error                     { return nil }
func (stubConn) LocalAddr() net.Addr              { return nil }
func (stubConn) RemoteAddr() net.Addr             { return nil }
func (stubConn) SetDeadline(time.Time) error      { return nil }
func (stubConn) SetReadDeadline(time.Time) error  { return nil }
func (stubConn) SetWriteDeadline(time.Time) error { return nil }

func TestNetHostPort(t *testing.T) {
	tests := []struct {
		name        string
		listener    net.Listener
		defaultHost Hostnamer
		host, port  string
	}{
		{"IPv6 address; nil default host", newMockListener(netAddr{"test", "[::1]:443"}), nil, "::1", "443"},
		{"IPv4 address; empty default host", newMockListener(netAddr{"test", "127.0.0.1:443"}), mockHostname(""), "127.0.0.1", "443"},
		{"IPv4 address; default host", newMockListener(netAddr{"test", "127.0.0.1:8080"}), mockHostname("localhost"), "localhost", "8080"},
		{"Port only; default DNS name", newMockListener(netAddr{"test", ":80"}), mockHostname("test.mozilla.org"), "test.mozilla.org", "80"},

		{"nil listener; nil default host", nil, nil, "", ""},
		{"Port only; no default host", newMockListener(netAddr{"test", ":443"}), nil, "", "443"},
		{"Invalid address; default host", newMockListener(netAddr{"test", "!@#$["}), mockHostname("localhost"), "localhost", ""},
		{"nil address; nil default host", newMockListener(nil), nil, "", ""},
	}
	for _, test := range tests {
		host, port := HostPort(test.listener, test.defaultHost)
		if host != test.host || port != test.port {
			t.Errorf("On test %s, got (%s, %s); want (%s, %s)", test.name,
				host, port, test.host, test.port)
		}
	}
}

func TestNetCanonicalURL(t *testing.T) {
	tests := []struct {
		name               string
		scheme, host, port string
		url                string
	}{
		// Should include non-default ports for well-known schemes.
		{"http; non-default port", "http", "localhost", "8000", "http://localhost:8000"},
		{"wss; non-default port", "wss", "localhost", "444", "wss://localhost:444"},

		// Should not include default ports for well-known schemes.
		{"https; default port", "https", "mozilla.org", "443", "https://mozilla.org"},
		{"ws; default port", "ws", "localhost", "80", "ws://localhost"},

		{"IPv4 address without port", "http", "127.0.0.1", "", "http://127.0.0.1"},
		{"IPv4 address with port", "wss", "127.0.0.1", "4444", "wss://127.0.0.1:4444"},
		{"IPv6 address without zone", "ws", "::1", "80", "ws://[::1]"},
		{"IPv6 address with zone", "http", "fe80::3%eth0", "8080", "http://[fe80::3%25eth0]:8080"},
	}
	for _, test := range tests {
		url := CanonicalURL(test.scheme, test.host, test.port)
		if url != test.url {
			t.Errorf("On test %s, got %s; want %s", test.name, url, test.url)
		}
	}
}

func TestNetParseRetryAfter(t *testing.T) {
	useMockFuncs()
	defer useStdFuncs()

	tests := []struct {
		name, header string
		expected     time.Duration
		ok           bool
	}{
		// RFC 7231.
		{"Integer seconds", "120", 2 * time.Minute, true},
		{"HTTP date format (RFC 1123)", "Tue, 10 Nov 2009 23:00:30 GMT", 30 * time.Second, true},

		// Non-standard, but permitted by http.ParseTime.
		{"RFC 850 date", "Tuesday, 10-Nov-09 23:01:30 GMT", 90 * time.Second, true},
		{"ANSI C date", "Tue Nov 10 23:00:15 2009", 15 * time.Second, true},

		{"Empty header value", "", 0, false},
		{"No delay", "0", 0, false},
		{"Invalid date", "hello", 0, false},
	}
	for _, test := range tests {
		actual, ok := ParseRetryAfter(test.header)
		if ok != test.ok || actual != test.expected {
			t.Errorf("On test %s, got (%s, %s); want (%s, %s)", test.name,
				actual, ok, test.expected, test.ok)
		}
	}
}

func TestNetLimitListenerClose(t *testing.T) {
	mckConn := stubConn(0)
	mckListener := &mockListener{
		accept: func() (net.Conn, error) {
			return mckConn, nil
		},
	}
	l := &LimitListener{Listener: mckListener, MaxConns: 1}
	defer l.Close()
	c, err := l.Accept()
	if err != nil {
		t.Fatalf("Error accepting connection to active listener: %s", err)
	}
	defer c.Close()
	bc, err := l.Accept()
	if err != nil {
		if err != errTooBusy {
			t.Errorf("Error rejecting connection to busy listener: got %#v; want %#v",
				err, errTooBusy)
		}
	} else {
		bc.Close()
		t.Fatalf("Expected %#v rejecting connection to busy listener", errTooBusy)
	}
	l.Close()
	cc, err := l.Accept()
	if err != nil {
		if err != errClosed {
			t.Errorf("Error rejecting connection to closed listener: got %#v; want %#v",
				err, errClosed)
		}
	} else {
		cc.Close()
		t.Fatalf("Expected %#v rejecting connection to closed listener", errClosed)
	}
}

func TestNetTooBusy(t *testing.T) {
	pipe := newPipeListener()
	l := &LimitListener{Listener: pipe, MaxConns: 1}
	defer l.Close()

	var wg sync.WaitGroup // Waits for the client to finish.
	wg.Add(1)
	dialChan := make(chan bool) // Synchronizes client and closer.
	timeout := closeAfter(2 * time.Second)

	go func() {
		defer wg.Done()
		c, err := pipe.Dial("", "")
		if err != nil {
			t.Errorf("Error dialing server: %s", err)
			return
		}
		select {
		case dialChan <- true:
		case <-timeout:
			t.Errorf("Timed out waiting for server to reject connection")
			return
		}
		c.Close()
		rc, err := pipe.Dial("", "")
		if err != nil {
			t.Errorf("Error reconnecting to server: %s", err)
		}
		rc.Close()
	}()

	c, err := l.Accept()
	if err != nil {
		t.Fatalf("Error accepting connection: %s", err)
	}
	bc, err := l.Accept()
	c.Close() // Close the initial connection.
	if err != nil {
		if err != errTooBusy {
			t.Errorf("Error rejecting connection: got %#v; want %#v",
				err, errTooBusy)
		}
	} else {
		bc.Close()
		t.Fatalf("Expected %#v rejecting connection", errTooBusy)
	}
	select {
	case <-dialChan:
	case <-timeout:
		t.Fatalf("Timed out waiting for client to dial server")
	}
	rc, err := l.Accept()
	if err != nil {
		t.Fatalf("Error accepting reconnection: %s", err)
	}
	rc.Close()
	wg.Wait()
}

func TestNetLimitListener(t *testing.T) {
	mckConn := &mockKeepAliver{Conn: stubConn(0)}
	acceptFunc := func() (net.Conn, error) {
		mckConn.Reset()
		return mckConn, nil
	}
	tests := []struct {
		name             string
		listener         net.Listener
		maxConns         int
		keepAlivePeriod  time.Duration
		keepAliveEnabled bool
	}{
		{"No keep-alive period; 1 connection", &mockListener{accept: acceptFunc}, 1, 0, false},
		{"3 minute keep-alive period; 1 connection", &mockListener{accept: acceptFunc}, 1, 3 * time.Minute, true},
		{"No keep-alive period; 5 connections", &mockListener{accept: acceptFunc}, 5, 0, false},
		{"5 minute keep-alive period; 10 connections", &mockListener{accept: acceptFunc}, 10, 5 * time.Minute, true},

		{
			name: "10 connections; keep-alive period not supported",
			listener: &mockListener{
				accept: func() (conn net.Conn, err error) {
					mckConn.Reset()
					return connOnly{mckConn}, nil
				},
			},
			maxConns:         5,
			keepAlivePeriod:  3 * time.Minute,
			keepAliveEnabled: false,
		},
	}
	for _, test := range tests {
		listener := &LimitListener{
			Listener:        test.listener,
			MaxConns:        test.maxConns,
			KeepAlivePeriod: test.keepAlivePeriod,
		}
		var (
			lastConn net.Conn
			err      error
		)
		for i := 0; i < test.maxConns; i++ {
			if lastConn, err = listener.Accept(); err != nil {
				t.Errorf("On test %s, error accepting connection: %s",
					test.name, err)
			}
			if mckConn.keepAlive != test.keepAliveEnabled {
				t.Errorf("On test %s, wrong keep-alive flag: got %v; want %v",
					test.name, mckConn.keepAlive, test.keepAliveEnabled)
			}
			d := time.Duration(0)
			if test.keepAliveEnabled {
				d = test.keepAlivePeriod
			}
			if mckConn.keepAlivePeriod != d {
				t.Errorf("On test %s, wrong keep-alive period: got %s; want %s",
					test.name, mckConn.keepAlivePeriod, d)
			}
		}
		// Exceeding the max connection count should return an error.
		if _, err = listener.Accept(); err != errTooBusy {
			t.Errorf("On test %s, wrong error: got %s; want %s",
				test.name, err, errTooBusy)
		}
		netErr, ok := err.(net.Error)
		if !ok {
			t.Errorf("On test %s, unexpected error type %T", test.name, err)
		}
		if netErr.Timeout() {
			t.Errorf("On test %s, unexpected timeout error: %s", test.name, netErr)
		}
		if !netErr.Temporary() {
			t.Errorf("On test %s, unexpected permanent error: %s", test.name, netErr)
		}
		// Close the last connection, then try reconnecting.
		lastConn.Close()
		if _, err := listener.Accept(); err != nil {
			t.Errorf("On test %s, error reconnecting: %s", test.name, err)
		}
	}
}

func TestNetBadTLSCipher(t *testing.T) {
	tlsConf, err := newTLSConfig()
	if err != nil {
		t.Fatalf("Error initializing TLS config: %s", err)
	}
	// We can't trigger an unsupported protocol version error, since Go's TLS
	// client doesn't allow SSL 3.0. Instead, we use an unsupported cipher suite
	// to trigger a handshake failure.
	tlsConf.MinVersion = tls.VersionTLS10
	tlsConf.CipherSuites = []uint16{
		tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
		tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
		tls.TLS_RSA_WITH_RC4_128_SHA,
	}
	pipe := newPipeListener()
	tlsLn := newTLSListener(pipe, tlsConf.Certificates[0])
	defer tlsLn.Close()

	var wg sync.WaitGroup // Waits for client handshake.
	wg.Add(1)

	go func() {
		defer wg.Done()
		conn, err := pipe.Dial("", "")
		if err != nil {
			t.Errorf("Error dialing server: %s", err)
			return
		}
		client := tls.Client(conn, tlsConf)
		err = client.Handshake()
		conn.Close()
		if err == nil {
			t.Errorf("Expected client handshake error")
		}
	}()

	server, err := tlsLn.Accept()
	if err != nil {
		t.Fatalf("Error accepting connection: %s", err)
	}
	err = server.(*tls.Conn).Handshake()
	server.Close()
	wg.Wait()
	errString := "no cipher suite supported by both client and server"
	if err != nil {
		if !strings.Contains(err.Error(), errString) {
			t.Errorf("Handshake error: got %q; want %q", err, errString)
		}
	} else {
		t.Errorf("Expected %q", errString)
	}
}

func TestNetListenTLS(t *testing.T) {
	tlsConf, err := newTLSConfig()
	if err != nil {
		t.Fatalf("Error initializing TLS config: %s", err)
	}
	pipe := newPipeListener()
	tlsLn := newTLSListener(pipe, tlsConf.Certificates[0])
	defer tlsLn.Close()

	var wg sync.WaitGroup // Synchronizes the handler and client.
	wg.Add(2)

	// Set up the HTTP server.
	expected := []byte("Reticulating splines...")
	srv := newServeCloser(&http.Server{
		Handler: http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {
			defer wg.Done()
			resp.Write(expected)
		}),
	})
	defer srv.Close()

	// Client goroutine.
	go func() {
		defer wg.Done()
		client := &http.Client{
			Transport: &http.Transport{
				Dial:                pipe.Dial,
				TLSClientConfig:     tlsConf,
				TLSHandshakeTimeout: 2 * time.Second,
			},
			Timeout: 2 * time.Second,
		}
		req := &http.Request{
			Method: "GET",
			URL:    &url.URL{Scheme: "https", Host: "example.com"},
		}
		resp, err := client.Do(req)
		if err != nil {
			t.Errorf("Error sending client request: %s", err)
			return
		}
		actual, err := ioutil.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			t.Errorf("Error reading client response body: %s", err)
			return
		}
		if !bytes.Equal(actual, expected) {
			t.Errorf("Wrong client response: got %q; want %q",
				actual, expected)
		}
	}()

	// Server goroutine.
	go srv.Serve(tlsLn)
	// Wait for the client and handler to finish.
	wg.Wait()
}
